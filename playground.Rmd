---
title: "load_map.rmd"
author: "Mikkel Plesner Ottosen & Magnus Bendix Borregaard"
date: "4/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages
```{r}
library(tidyverse)
library(raster)
library(sf)
library(leaflet)
library(hash)
library(rgeos)
library(spatstat)
```

## Loading satellite image & generating NDVI
```{r}
aarhus_lng <- 10.2
aarhus_lat <- 56.15
aarhus_zoom <- 11
# EPSG 3857
aarhus_NIR <- raster('data/32VNH_0_B08,B04,B03.tiff', band = 1)
aarhus_red <- raster('data/32VNH_0_B08,B04,B03.tiff', band = 2)
aarhus_NDVI <- (aarhus_NIR - aarhus_red) / (aarhus_NIR + aarhus_red)

# Project image, since EPSG 3857 is bad with distances in Denmark
aarhus_NDVI <- projectRaster(aarhus_NDVI, crs = 25832)
# Unfortunately there were a lot of algae (or something like it) in the harbor when the image was taken
plot(aarhus_NDVI)
```

## NDVI threshold for 'green areas'
```{r}
# Reclassify to 'no vegetation', 'low vegetation', and 'high vegetation'
# from, to, new class
m_3_class <- matrix(c(-1.1, 0.2, NA, # no veg
              0.2, 0.5, 1, # low veg
              0.5, 1, 2), # high veg
            ncol=3, byrow=TRUE)

aarhus_veg_3class <- reclassify(aarhus_NDVI, m_3_class)

# Reclassify to 'no vegetation' and 'vegetation'
m_2_class <- matrix(c(-1.1, 0.6, NA, # no veg
              0.6, 1, 1), # veg
            ncol=3, byrow=TRUE)

aarhus_veg_2class <- reclassify(aarhus_NDVI, m_2_class)

# Show on map so we can validate a good NDVI threshold and minimum area for green areas
leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addRasterImage(aarhus_veg_2class, group = 'No & high veg') %>% 
  addRasterImage(aarhus_veg_3class, group = 'No, low, & high veg') %>% 
  setView(lng = aarhus_lng, lat = aarhus_lat, zoom = aarhus_zoom) %>%
  addLayersControl(
    overlayGroups = c("No & high veg", "No, low, & high veg"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% hideGroup("No, low, & high veg")
```

## Filter off small areas
High vegetation (> 0.6 NDVI) seems to match pretty well with our definition of a green area, and about 10 pixels (~200^2) looks to be a good cutoff size for a green area.
```{r}
# Rename the best raster for ease of use
aarhus_veg <- aarhus_veg_2class

# Number of pixels^2 for minimum allowed size to be called a 'green area'
area_min_pix <- 10 # 10 pixels (~200m^2) seems to be just too small

# Create a dictionary that allows us to filter off areas that are small
# since the number of pixels with a given ID directly corresponds
# to the area of that green area
id_counts <- hash()

# Give every pixel an ID corresponding to which green area it is a part of
area_map <- clump(aarhus_veg, direction = 4) # only use rook's case, since areas are often separated diagonally
# Select only the values we need
area_ids <- area_map@data@values

# Count how many there are of every ID
for (id in area_ids) {
  id <- toString(id)
  
  if (!has.key(id, id_counts)) {
    id_counts[[id]] <- 1
  } else {
    id_counts[[id]] <- id_counts[[id]] + 1
  }
}
del("NA", id_counts)

# Remove big areas from list of areas
# (we just need at list of the areas to REMOVE from the original raster)
for (key in keys(id_counts)) {
  # Calculate the m^2 area
  area_size <- id_counts[[key]]
  
  # Remove big areas from this dictionary
  if (area_size > area_min_pix) {
    del(key, id_counts)
  }
}

# Remove pixels that belong to small areas
for (i in 1:length(area_ids)) {
  # Select the green area ID of the pixel
  val <- toString(area_ids[[i]])
  
  # Whether to remove this pixel
  remove_pixel <- has.key(val, id_counts)
  
  # Set the corresponding pixel in the original raster to NA
  # since it is part of small area
  if (remove_pixel) {
    aarhus_veg@data@values[[i]] <- NA
  }
}

# See if the areas line up as expected
leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addRasterImage(aarhus_veg) %>% 
  setView(lng = aarhus_lng, lat = aarhus_lat, zoom = aarhus_zoom)
```

## Generating distance heatmap
```{r}
# Copy the green areas raster so we don't mutate the original
aarhus_dist_heatmap <- aarhus_veg

# Reclassify ones to zeroes
# every 1 symbolizes a green area, but we now need it to symbolize the distance to the nearest green area (which is 0)
m <- matrix(c(1, 0),
            ncol=2, byrow=TRUE)
aarhus_dist_heatmap <- reclassify(aarhus_dist_heatmap, m)

# Fill in every transparent pixel (NA) with the value of the distance to nearest green pixel
aarhus_dist_heatmap <- distance(aarhus_dist_heatmap)

# Define a color gradient for drawing distances
veg_colors <- colorRampPalette(c("darkgreen", "lightblue"))

# Check plot for the highest distance found only on land (so we can remove very high values only found at sea)
plot(aarhus_dist_heatmap, col = veg_colors(20))

# Color picker says ~1km to green area is max on land, so we set it to 1.2km to be safe
max_dist <- 1200 # meters

# Verify that 1200 meters is a good cutoff point
hist(aarhus_dist_heatmap, breaks = 1200/20)

# Reclassify longer distances to not stretch the color gradient as much
m <- matrix(c(max_dist, Inf, NA),
            ncol=3, byrow=TRUE)
aarhus_dist_heatmap <- reclassify(aarhus_dist_heatmap, m)

palette <- colorNumeric(
    veg_colors(100),
    raster::values(aarhus_dist_heatmap),
    na.color = "transparent"
  )

# See that the heatmap lines up with green areas
leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addRasterImage(
    aarhus_dist_heatmap,
    group = "Heatmap",
    colors = veg_colors(100)
  ) %>% 
  setView(lng = aarhus_lng, lat = aarhus_lat, zoom = aarhus_zoom) %>%
  addLegend(
    "bottomright",
    pal = palette,
    values = raster::values(aarhus_dist_heatmap),
    title = "Dist. (m.)",
    group = "Heatmap",
    opacity = 1
  ) %>%
  addLayersControl(
    overlayGroups = c("Heatmap"),
    options = layersControlOptions(collapsed = FALSE)
  ) 

```

## Load & crop roads
```{r}

roads_4326 <- st_read('data/osm-roads/gis_osm_roads_free_1.shp')

# transform roads crs to match raster, any version of Aarhus will do
roads_25832 <- st_transform(roads_4326 , crs = crs(aarhus_NDVI)) 

compareCRS(roads_25832, crs(aarhus_NDVI)) # ready to crop

aarhus_box <- st_make_grid(aarhus_NDVI, n = 1) # bounding box of satellite image

roads_cropped <- st_intersection(aarhus_box, roads_25832)
```

## Display the final app
```{r}
leaflet() %>%
  # For finding a specific location
  addProviderTiles("OpenStreetMap") %>%
  # The heatmap
  addRasterImage(
    aarhus_dist_heatmap,
    group = "Heatmap",
    colors = veg_colors(100)
  ) %>% 
  # The actual green areas
  addRasterImage(
    aarhus_veg,
    group = "Heatmap",
    colors = "#36453B"
  ) %>% 
  # Roads make it easier to understand locations when in heatmap mode
  addPolylines(
    data = st_transform(roads_cropped, crs = 4326),
    weight = 3,
    opacity = 0.3,
    color = "#fff",
    group = "Heatmap") %>%
  # Look at Aarhus
  setView(lng = aarhus_lng, lat = aarhus_lat, zoom = aarhus_zoom) %>%
  # Shows colors of the distances
  addLegend(
    "bottomright",
    pal = palette,
    values = raster::values(aarhus_dist_heatmap),
    title = "Dist. (m.)",
    group = "Heatmap",
    opacity = 1
  ) %>%
  # Toggle heatmap mode
  addLayersControl(
    overlayGroups = c("Heatmap"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% hideGroup("Heatmap")
```

## Are green areas clustered?
```{r}
# Clump together pixels to make a polygon for every area
aarhus_veg_clump <- clump(aarhus_veg, direction = 4)
aarhus_veg_poly <- rasterToPolygons(aarhus_veg_clump, dissolve = TRUE)

# Convert to sf to use sf methods
aarhus_veg_poly <- st_as_sf(aarhus_veg_poly)

# Calulate centroids to get points to analyse
aarhus_veg_centroids <- st_centroid(aarhus_veg_poly)

# Generate window necessary for ppp conversion
win_xrange <- extent(aarhus_veg_centroids)[1:2]
win_yrange <- extent(aarhus_veg_centroids)[3:4]
centroid_owin <- owin(xrange = win_xrange, yrange = win_yrange)

# Separate coordinates into separate columns, which is necessary for ppp conversion
aarhus_veg_centroids <- aarhus_veg_centroids %>%
  mutate(x = unlist(map(aarhus_veg_centroids$geometry, 1)),
         y = unlist(map(aarhus_veg_centroids$geometry, 2)))

# Convert centroids to ppp
aarhus_veg_centroids <- ppp(x = aarhus_veg_centroids$x, y = aarhus_veg_centroids$y, centroid_owin)

# Perform quadrat test to see if green areas are clustered
quad_test <- quadrat.test(aarhus_veg_centroids, nx = 10, ny = 10)
quad_test
plot(quad_test)
```





