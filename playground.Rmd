---
title: "load_map.rmd"
author: "Magnus Bendix Borregaard"
date: "4/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages
```{r}
library(raster)
library(sf)
library(leaflet)
library(hash)
```

## Loading satellite image & generating NDVI
```{r}
aarhus_NIR <- raster('data/32VNH_0_B08,B04,B03.tiff', band = 1)
aarhus_red <- raster('data/32VNH_0_B08,B04,B03.tiff', band = 2)
aarhus_NDVI <- (aarhus_NIR - aarhus_red) / (aarhus_NIR + aarhus_red)

# Unfortunately there were a lot of algae (or something like it) in the harbor when the image was taken
plot(aarhus_NDVI)
```

## NDVI threshold for 'green areas'
```{r}
# Resolution of satellite image is 35.991m^2, so we can just use the first index
pixel_size <- res(aarhus_NDVI)[1]

# Reclassify to 'no vegetation', 'low vegetation', and 'high vegetation'
# from, to, new class
m_3_class <- matrix(c(-1.1, 0.2, NA, # no veg
              0.2, 0.5, 1, # low veg
              0.5, 1, 2), # high veg
            ncol=3, byrow=TRUE)

aarhus_veg_3class <- reclassify(aarhus_NDVI, m_3_class)

# Reclassify to 'no vegetation' and 'vegetation'
m_2_class <- matrix(c(-1.1, 0.6, NA, # no veg
              0.6, 1, 1), # veg
            ncol=3, byrow=TRUE)

aarhus_veg_2class <- reclassify(aarhus_NDVI, m_2_class)

#plot(aarhus_veg_2class)

# Show on map so we can validate a good NDVI threshold and minimum area for green areas
leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addRasterImage(aarhus_veg_2class, group = 'No & high veg') %>% 
  addRasterImage(aarhus_veg_3class, group = 'No, low, & high veg') %>% 
  setView(lng = 10.2, lat = 56.15, zoom = 11) %>% # Aarhus
  addLayersControl(
    overlayGroups = c("No & high veg", "No, low, & high veg"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% hideGroup("No, low, & high veg")
```
High vegetation (> 0.6 NDVI) seems to match pretty well with our definition of a green area, and about 10 pixels (~360m^2) looks to be a good minimum size for a green area.

## Filter off small areas
```{r}
# m^2 for minimum allowed size to be called a 'green area'
area_min_size <- 360 # EDIT THIS TO SOMETHING ELSE, THE RESOLUTION IS INCORRECT

# Rename the best raster for ease of use
aarhus_veg <- aarhus_veg_2class

# Create a dictionary that allows us to filter off areas that are small
# since the number of pixels with a given ID directly corresponds
# to the area of that green area
id_counts <- hash()

# Give every pixel an ID corresponding to which green area it is a part of
area_map <- clump(aarhus_veg, direction = 4)
# Select only the values we need
area_ids <- area_map@data@values

# Count how many there are of every ID
for (id in area_ids) {
  id <- toString(id)
  
  if (is.null(id_counts[[id]])) {
    id_counts[[id]] <- 1
  } else {
    id_counts[[id]] <- id_counts[[id]] + 1
  }
}
del("NA", id_counts)

# Convert from pixel count to m^2 for every green area and remove big areas
# (we just need at list of the areas to REMOVE from the original raster)
for (key in keys(id_counts)) {
  # Calculate the m^2 area
  area_size <- id_counts[[key]] * pixel_size
  
  # Remove big areas from this dictionary
  if (area_size > area_min_size) {
    del(key, id_counts)
  }
}

for (i in 1:length(area_ids)) {
  # Select the green area ID of the pixel
  val <- toString(area_ids[[i]])
  
  # Whether to remove this pixel
  remove_pixel <- has.key(val, id_counts)
  
  # Set the corresponding pixel in the original raster to NA
  # since it is part of small area
  if (remove_pixel) {
    aarhus_veg@data@values[[i]] <- NA
  }
}

leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addRasterImage(aarhus_veg) %>% 
  setView(lng = 10.2, lat = 56.15, zoom = 11) # Aarhus


```
## Generating distance heatmap
```{r}
# copy the green area raster
# reclass every 1 to a 0 in the copy (every 1 symbolizes a green area, but we now need it to symbolize the distance to the nearest green area)
# use 'distance' from 'raster' package to fill every NA with the distance to the nearest 0-pixel

# Copy the green areas raster so we don't mutate the original
aarhus_crow_heatmap <- aarhus_veg

# Reclassify ones to zeroes
# every 1 symbolizes a green area, but we now need it to symbolize the distance to the nearest green area (which is 0)
m <- matrix(c(1, 0),
            ncol=2, byrow=TRUE)

aarhus_crow_heatmap <- reclassify(aarhus_crow_heatmap, m)
aarhus_crow_heatmap <- distance(aarhus_crow_heatmap)
tail(aarhus_crow_heatmap)
crs(aarhus_NDVI)
```

## Loading & cropping roads
```{r}

roads_4326 <- st_read('data/osm-roads/gis_osm_roads_free_1.shp')

# transform roads crs to match raster, any version of Aarhus will do
roads_3857 <- st_transform(roads_4326 , crs = crs(aarhus_NDVI)) 

compareCRS(roads_3857, crs(aarhus_NDVI)) # ready to crop

aarhus_box <- st_make_grid(aarhus_NDVI, n = 1) # bounding box of satellite image

roads_cropped <- st_intersection(aarhus_box, roads_3857)

# Check that roads are cropped and line up
leaflet() %>%
  addProviderTiles("OpenStreetMap") %>%
  addPolylines(data = st_transform(roads_cropped, crs = 4326)) %>%
  setView(lng = 10.2, lat = 56.15, zoom = 11) # Aarhus
  
```












