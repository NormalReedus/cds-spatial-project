---
title: "load_map.rmd"
author: "Mikkel Plesner Ottosen & Magnus Bendix Borregaard"
date: "4/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages
```{r}
library(raster)
library(sf)
library(leaflet)
library(hash)
```

## Loading satellite image & generating NDVI
```{r}
aarhus_lng <- 10.2
aarhus_lat <- 56.15
aarhus_zoom <- 11
# EPSG 3857
aarhus_NIR <- raster('data/32VNH_0_B08,B04,B03.tiff', band = 1)
aarhus_red <- raster('data/32VNH_0_B08,B04,B03.tiff', band = 2)
aarhus_NDVI <- (aarhus_NIR - aarhus_red) / (aarhus_NIR + aarhus_red)

# Project image, since EPSG 3857 is bad with distances in Denmark
aarhus_NDVI <- projectRaster(aarhus_NDVI, crs = 25832)
# Unfortunately there were a lot of algae (or something like it) in the harbor when the image was taken
plot(aarhus_NDVI)
```

## NDVI threshold for 'green areas'
```{r}
# Reclassify to 'no vegetation', 'low vegetation', and 'high vegetation'
# from, to, new class
m_3_class <- matrix(c(-1.1, 0.2, NA, # no veg
              0.2, 0.5, 1, # low veg
              0.5, 1, 2), # high veg
            ncol=3, byrow=TRUE)

aarhus_veg_3class <- reclassify(aarhus_NDVI, m_3_class)

# Reclassify to 'no vegetation' and 'vegetation'
m_2_class <- matrix(c(-1.1, 0.6, NA, # no veg
              0.6, 1, 1), # veg
            ncol=3, byrow=TRUE)

aarhus_veg_2class <- reclassify(aarhus_NDVI, m_2_class)

# Show on map so we can validate a good NDVI threshold and minimum area for green areas
leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addRasterImage(aarhus_veg_2class, group = 'No & high veg') %>% 
  addRasterImage(aarhus_veg_3class, group = 'No, low, & high veg') %>% 
  setView(lng = aarhus_lng, lat = aarhus_lat, zoom = aarhus_zoom) %>%
  addLayersControl(
    overlayGroups = c("No & high veg", "No, low, & high veg"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% hideGroup("No, low, & high veg")
```
## Filter off small areas
High vegetation (> 0.6 NDVI) seems to match pretty well with our definition of a green area, and about 10 pixels (~200^2) looks to be a good cutoff size for a green area.
```{r}
# Rename the best raster for ease of use
aarhus_veg <- aarhus_veg_2class

# Number of pixels^2 for minimum allowed size to be called a 'green area'
area_min_pix <- 10 # 10 pixels (~200m^2) seems to be just too small

# Create a dictionary that allows us to filter off areas that are small
# since the number of pixels with a given ID directly corresponds
# to the area of that green area
id_counts <- hash()

# Give every pixel an ID corresponding to which green area it is a part of
area_map <- clump(aarhus_veg, direction = 4) # only use rook's case, since areas are often separated diagonally
# Select only the values we need
area_ids <- area_map@data@values

# Count how many there are of every ID
for (id in area_ids) {
  id <- toString(id)
  
  if (!has.key(id, id_counts)) {
    id_counts[[id]] <- 1
  } else {
    id_counts[[id]] <- id_counts[[id]] + 1
  }
}
del("NA", id_counts)

# Remove big areas from list of areas
# (we just need at list of the areas to REMOVE from the original raster)
for (key in keys(id_counts)) {
  # Calculate the m^2 area
  area_size <- id_counts[[key]]
  
  # Remove big areas from this dictionary
  if (area_size > area_min_pix) {
    del(key, id_counts)
  }
}

# Remove pixels that belong to small areas
for (i in 1:length(area_ids)) {
  # Select the green area ID of the pixel
  val <- toString(area_ids[[i]])
  
  # Whether to remove this pixel
  remove_pixel <- has.key(val, id_counts)
  
  # Set the corresponding pixel in the original raster to NA
  # since it is part of small area
  if (remove_pixel) {
    aarhus_veg@data@values[[i]] <- NA
  }
}

# See if the areas line up as expected
leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addRasterImage(aarhus_veg) %>% 
  setView(lng = aarhus_lng, lat = aarhus_lat, zoom = aarhus_zoom)
```

## Generating distance heatmap
```{r}
# Copy the green areas raster so we don't mutate the original
aarhus_crow_heatmap <- aarhus_veg

# Reclassify ones to zeroes
# every 1 symbolizes a green area, but we now need it to symbolize the distance to the nearest green area (which is 0)
m <- matrix(c(1, 0),
            ncol=2, byrow=TRUE)
aarhus_crow_heatmap <- reclassify(aarhus_crow_heatmap, m)

# Fill in every transparent pixel (NA) with the value of the distance to nearest green pixel
aarhus_crow_heatmap <- distance(aarhus_crow_heatmap)

# Define a color gradient that allows us to identify ~all distances, that are only found at sea
veg_colors <- colorRampPalette(c("darkgreen", "lightblue"))
# Check plot for the highest distance found only on land
plot(aarhus_crow_heatmap, col = veg_colors(20)) # color picker says ~1km to green area is max on land

# Reclassify longer distances to not stretch the color gradient as much
max_dist <- 1200 # meters
m <- matrix(c(max_dist, Inf, NA),
            ncol=3, byrow=TRUE)
aarhus_crow_heatmap <- reclassify(aarhus_crow_heatmap, m)

palette <- colorNumeric(
    veg_colors(100),
    raster::values(aarhus_crow_heatmap),
    na.color = "transparent"
  )

# See the final heatmap
leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addRasterImage(
    aarhus_crow_heatmap,
    group = "As the crow flies",
    colors = veg_colors(100)
  ) %>% 
  setView(lng = aarhus_lng, lat = aarhus_lat, zoom = aarhus_zoom) %>%
  addLayersControl(
    overlayGroups = c("As the crow flies"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    "bottomright",
    pal = palette,
    values = raster::values(aarhus_crow_heatmap),
    title = "Dist. (m.)",
    opacity = 1
  )

```

## Loading & cropping roads
```{r}

roads_4326 <- st_read('data/osm-roads/gis_osm_roads_free_1.shp')

# transform roads crs to match raster, any version of Aarhus will do
roads_3857 <- st_transform(roads_4326 , crs = crs(aarhus_NDVI)) 

compareCRS(roads_3857, crs(aarhus_NDVI)) # ready to crop

aarhus_box <- st_make_grid(aarhus_NDVI, n = 1) # bounding box of satellite image

roads_cropped <- st_intersection(aarhus_box, roads_3857)

# Check that roads are cropped and line up
leaflet() %>%
  addProviderTiles("OpenStreetMap") %>%
  addPolylines(data = st_transform(roads_cropped, crs = 4326)) %>%
  setView(lng = aarhus_lng, lat = aarhus_lat, zoom = aarhus_zoom)
  
```

<<<<<<< HEAD
```{r}
=======
>>>>>>> bb8e68c2c4a9f59530e98936aac1f032d9cd8e82


<<<<<<< HEAD
clumps[1128, 2]


```
=======









>>>>>>> bb8e68c2c4a9f59530e98936aac1f032d9cd8e82
